{"pages":[],"posts":[{"title":"m1 맥에서 144hz 롤하기","text":"결론부터 말하면 롤 설정 값을 바꿔주면 m1 macbook Air로 144hz 방어가 가능하다. 테스트 스펙 macbook air m1(2020) 8g 256gb (깡통 맥북에어 옵션) qhd 165hz 외장모니터 방법1. finder - ‘응용 프로그램’ - ‘리그오브레전드’ 오른쪽클릭 ‘패키지 내용보기’ 2. 아래의 경로로 들어감 LoL/Config/game.cfg 텍스트 에디터로 열기 3. [General] 마지막 항목에 “MetalBetaTest=true” 추가 결론 상옵기준 매우 쾌적하게 플레이 가능 (심지어 발열도 없다.) 심지어 한타중에도 프레임드랍이 없다…🤔 게임하려고 맥북사는 사람들은 없겠지만 롤하려고 맥북은 사도 될지도…? 참고 : Mac on Metal Beta Testing","link":"/2021/11/01/%EA%B2%8C%EC%9E%84/2021-10-30-m1-league-of-legend/"},{"title":"개략적인 규모 추정","text":"2의 제곱 수 최소단위는 1바이트, 8비트 아스키 문자 하나 메모리크기가 1바이트 모든 프로그래머가 알아야 하는 응답 지연 값 메모리는 빠르지만 디스크는 아직도 느리다 디스크 탐색은 가능한 한 피하라 단순한 압축 알고리즘은 빠르다 데이터를 인터넷으로 전송하기 전에 가능하면 압축하라 데이터 센터는 보통 여러 지역에 분산되어있고, 센터들 간에 데이터를 주고 받는 데는 시간이 걸린다 가용성에 관계된 수치들 고가용성 시스템이 오랜 기간동안 지속적으로 중단 없이 운영될 수 있는 능력 예제: 트위터 QPS와 저장소 요구량 추정가정 월간 능동 사용자(mau) 3억 명 50%가 매일 사용 각 사용자는 매일 2건 미디어 포함 10% 데이터는 5년 보관 추정 QPS(Query Per Second) 추정치 일간 능동 사용자(dau) = 3억 x 50% = 1.5억 QPS = 1.5억 x 2건 / 24시간 / 3600초 = 약 3500 최대 QPS = 2 x QPS = 약 7000 미디어 저장을 위한 저장소 요구량 평균 크기 id = 64바이트 body = 140바이트 미디어 = 1MB 미디어 저장소 요구량 : 1.5억 x 2 x 10% x 1MB = 30TB/day 5년간 미디어를 보관하기 위한 저장소 요구량 : 30TB x 365 x 5 = 약 55PB","link":"/2021/11/01/%EA%B0%80%EC%83%81%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84%EA%B8%B0%EC%B4%88/2021-10-13-%EA%B0%9C%EB%9E%B5%EC%A0%81%EC%9D%B8-%EA%B7%9C%EB%AA%A8-%EC%B6%94%EC%A0%95/2021-10-13-%EA%B0%9C%EB%9E%B5%EC%A0%81%EC%9D%B8-%EA%B7%9C%EB%AA%A8-%EC%B6%94%EC%A0%95/"},{"title":"사용자 수에 따른 규모 확장성","text":"요약 웹 계층은 무상태 계층으로 모든 계층에 다중화 도입 가능한 많은 데이터를 캐시할 것 여러 데이터 센터를 지원할 것 정적 콘텐츠는 CDN을 통해 서비스할 것 데이터 계층은 샤딩을 통에 그 규모를 확장할 것 각 계층은 독립적 서비스로 분할할 것 시스템을 지속적으로 모니터링 하고, 자동화 도구들을 활용할 것 단일서버시스템이 단일 서버로 구현되어있다고 가정할 시 프로세스 사용자가 도메인(api.mysite.com)으로 접속한다. DNS에 질의하여 IP주소로 반환된다. (DNS는 제3사업자임) IP주소로 HTTP 요청 HTML or Json으로 응답 데이터베이스RDBMS vs NoSQL RDBMS 오라클, MySQL, PostegreSQL 열, 컬럼으로 표현 Join으로 합침 NoSQL MongoDB … Join 지원 안함 NoSQL 쓰는 경우 속도 중요할 시 비정형 데이터일 시 데이터 직렬화, 역직렬화 용 대량의 데이터 수직적 규모 확장 vs 수평적 규모 확장Sacale-Up vs Sacale-OutScale-Up : 단일 서버 사양을 높임 Scale-Out : 서버 수를 추가 Sacale-Up 아닌 Sacale-Out이 유리한 이유 한 대의 서버 메모리를 무한대로 증설할 방법이 없음 장애에 대한 자동복구 방안이나 다중화 제시 X 로드밸런서(LB) 트래픽 분산의 역할 DB 다중화 이중화 시 master-slave로 나눔 master는 write, slave는 read 보통 read연산 비중이 훨씬 높고 slave DB가 더 많음 → 성능 캐시 값비싼 연산 결과나 자주 참조되는 데이터를 저장하는 메모리 캐시 사용 시 고려해야 할 것 영속적인 데이터 X 만료(expire) 방식 LRU → 가장 자주 씀 LFU FIFO 데이터 일관성 유지 방식 콘텐츠 전송 네크워크(CDN) 정적 콘텐츠 캐싱 CSS, JS, 이미지, 비디오 무상태(stateless) 웹 계층 Scale-Out 시 중요 상태정보를 웹 계층에서 제거 상태 정보를 웹 말고 DB에 저장 MSA시 공유저장소를 활용 Redis, NoSQL 활용 데이터센터 통상적으로 지리적으로 가장 가까운 곳으로 라우팅(Geo-routing) 구축 시 신경써야 할 것 트래픽 우회 데이터 동기화 테스트와 배포 → Message Queue는 시스템이 독립적으로 확장할 수 있는 핵심전략 메시지 큐 무손실, 비동기 pub-sub 방식 데이터베이스의 규모 확장샤딩(sharding) DB를 scale-out 하는 것 모든 샤드는 같은 스키마를 쓰지만 데이터 중복은 없음 샤딩 키를 정하는 것이 중요","link":"/2021/11/01/%EA%B0%80%EC%83%81%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84%EA%B8%B0%EC%B4%88/2021-10-13-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%88%98%EC%97%90-%EB%94%B0%EB%A5%B8-%EA%B7%9C%EB%AA%A8-%ED%99%95%EC%9E%A5%EC%84%B1/2021-10-13-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%88%98%EC%97%90-%EB%94%B0%EB%A5%B8-%EA%B7%9C%EB%AA%A8-%ED%99%95%EC%9E%A5%EC%84%B1/"},{"title":"시스템 설계 면접 공략법","text":"효과적 면접을 위한 4단계 접근법1. 문제 이해 및 설계 범위 확정 구체적으로 어떤 기능들을 만들어야 하나 제품 사용자 수는 얼마나 되나 회사의 규모는 얼마나 빨리 커지리라 예상하나? 석 달, 여섯 달, 일년 뒤의 규모는 얼마가 되리라 예상하는가 회사가 주로 사용하는 기술 스택은 무엇인가 설계를 단순화 하기 위한 기존 서비스로는 어떤 것이 있는가 → 중요한 것은 모호함을 없에는 것 2. 개략적인 설계안 제시 및 동의 구하기 청사진을 만들고 의견을 구하라ㅋ 화이트보드에 다이어그램 그리기 클라이언트, API, 웹서버, DB, 캐시, CDN, MQ 등 청사진이 제약사항에 부합하는지 확인하라 3. 상세 설계 시스템에서 전반적으로 달성해야 할 목표와 기능 범위 확인 전체 설계의 개략적 청사진 마련 해당 청사진에 대한 면접관의 의견 청취 상세 설계에서 집중해야 할 영역들 확인 4. 마무리 개선점 찾기 ex&gt; 병목구간 설계 핵심 요약 운영 관련 이슈 메트릭, 모니터링, 로그, 배포 등 시스템 확장 방식","link":"/2021/11/01/%EA%B0%80%EC%83%81%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84%EA%B8%B0%EC%B4%88/2021-10-13-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EB%A9%B4%EC%A0%91-%EA%B3%B5%EB%9E%B5%EB%B2%95/2021-10-13-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EB%A9%B4%EC%A0%91-%EA%B3%B5%EB%9E%B5%EB%B2%95/"},{"title":"안정 해시 설계","text":"수평적 규모 확장을 위해서는 요청 또는 데이터를 서버로 균등하게 나누는 것이 중요안정 해시는 이 목표를 달성하기 위해 보편적으로 사용하는 기술 안정 해시 설계의 이점 서버가 추가되거나 삭제될 때 재배치되는 키의 수가 최소화된다. 데이터가 보다 균등하게 분포하게 되므로 수평적 규모 확장성을 달성하기 쉽다. 핫스팟(hotspot) 키 문제를 줄인다. 만약 잘 분배가 되어있던 서버 하나가 죽었을 경우?기존 해시 테이블 모든 키를 재배치함 안정 해시 이상이 있는 부분만 재배치 기본 구현법 서버와 키를 균등 분포 해시 함수를 사용해 해시 링에 배치한다. 키의 위치에서 링을 시계 방향을 탐색하다 만나는 최초의 서버가 키가 저장될 서버다. 문제점 서버가 추가되거나 삭제될 때 파티션의 크기를 균등하게 유지하는게 불가능 키의 균등 분포를 달성하기가 어려움 가상 노드 기본 구현법의 문제를 해결하기 위한 방법실제 노드를 가르키는 가상 노드를 만들어 해시 링에 균등하게 배치하는 방법","link":"/2021/11/01/%EA%B0%80%EC%83%81%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84%EA%B8%B0%EC%B4%88/2021-10-13-%EC%95%88%EC%A0%95-%ED%95%B4%EC%8B%9C-%EC%84%A4%EA%B3%84/2021-10-13-%EC%95%88%EC%A0%95-%ED%95%B4%EC%8B%9C-%EC%84%A4%EA%B3%84/"},{"title":"처리율 제한 장치의 설계","text":"처리율 제한 장치의 설계 API 요청횟수가 특정 임계치를 넘어가면 추가로 도달한 요청은 처리를 중단하는 것 장점 DoS공격 방지 비용절감 서버 과부하 방지 처리율 제한 알고리즘토큰 버킷&gt; 토큰을 발급하고 토큰의 갯수 만큼만 API 요청을 버킷에 담음 버킷이 가득 찬 경우 API요청은 버려짐(overflow) &gt; - 가장 간단하고 폭넓게 사용됨(아마존 등) - 메모리 효율성 높음 - 버킷크기:토큰공급률 비율 튜닝이 관건 누출 버킷&gt; 토큰 버킷 알고리즘과 유사하지만 처리율이 고정 큐(FIFO)로 구현 &gt; 동작방식 요청이 도착하면 큐가 가득 차 있는지 확인, 빈자리가 있는 경우 큐에 요청 추가 큐가 가득 차있는 경우 새 요청은 버림 지정된 시간마다 큐에서 요청을 꺼내어 처리 토큰 버킷 알고리즘과 유사 고정된 처리율을 가지고 있어 안정적 출력이 필요한 환경에 적합 단시간에 많은 처리율이 들어올 경우 취약함 고정 윈도 카운터 동작방식 타임라인을 고정된 간격의 윈도로 나누고, 각 윈도마다 카운터를 붙임 요청이 접수될 때마다 이 카운터의 값은 1씩 증가함 이 카운터 값이 사전에 설정된 임계치에 도달하면 새로운 요청은새 윈도가 열릴 때 까지 버려짐 - 메모리 효율 좋음 - 윈도 경계에서 일시적으로 많은 트래픽이 몰려드는 경우, 기대했던 시스템의 처리 한도보다 많은 양의 요청을 처리하게 됨 이동 윈도 로그&gt; 고정 윈도 카운터 알고리즘의 윈도 경계 부분에서 트래픽이 몰리는 경우를 보완하기 위한 알고리즘 &gt; 동작방식 요청의 타임스탬프를 추적함타임스탬프는 보통 Redis의 Sorted Set과 같은 정렬 집합 캐시에 보관 새 요청이 오면 만료된 타임스탬프는 제거 새 요청의 타임 스탬프를 로그에 추가 로그의 크기가 허용치보다 같거나 작으면 요청을 시스템에 전달함그렇지 않은 경우 처리는 거부됨 윈도 알고리즘의 처리율 한도를 넘지 않음 다량의 메모리 사용, 거부된 요청의 타임스탬프도 보관하기 때문 이동 윈도 카운터&gt; 고정 윈도 카운터 + 이동 윈도 로그 &gt; - 이전 시간대의 평균 처리율에 따라 현재 윈도의 상태를 계산하므로 짧은 시간에 몰리는 트래픽에도 잘 대응 - 메모리 효율이 좋음 - 직전 시간의 추정치를 계산하기 때문에 기준이 느슨함, But 심각한 건 아님 프로세스 처리율 제한 규칙은 디스크에 보관한다.작업 프로세스는 수시로 규칙을 디스크에서 읽어 캐시에 저장한다. 클라이언트가 요청을 서버에 보내면 요청은 먼저 처리율 제한 미들웨어에 도달한다.카운터 및 마지막 요청의 타임스탬프를 레디스 캐시에서 가져온다. 해당 요청이 처리율 제한에 걸리지 않은 경우 API서버로 보낸다. 해당 요청이 처리율 제한에 걸렸다면 429(too many request) 에러를 클라이언트에 보낸다.한편 해당 요청은 그대로 버릴 수도 있고 메시지 큐에 저장할 수도 있다.","link":"/2021/11/01/%EA%B0%80%EC%83%81%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84%EA%B8%B0%EC%B4%88/2021-10-13-%EC%B2%98%EB%A6%AC%EC%9C%A8-%EC%A0%9C%ED%95%9C-%EC%9E%A5%EC%B9%98%EC%9D%98-%EC%84%A4%EA%B3%84/2021-10-13-%EC%B2%98%EB%A6%AC%EC%9C%A8-%EC%A0%9C%ED%95%9C-%EC%9E%A5%EC%B9%98%EC%9D%98-%EC%84%A4%EA%B3%84/"},{"title":"싱글톤 패턴","text":"해당 클래스의 인스턴스가 하나만 만들어지고,어디서든지 그 인스턴스에 접근할 수 있도록 하기 위한 패턴 고전적인 싱글톤 패턴 (문제 있음)12345678910111213public class Singleton { private static Singleton uniqueInstance; private Singleton(){} public static Singleton getInstance(){ if (uniqueInstance == null){ uniqueInstance = new Singleton(); } return uniqueInstance; } } 멀티쓰레드 환경에서는 123if (uniqueInstance == null){ uniqueInstance = new Singleton();} 이 부분에서 2개 이상의 인스턴스가 생성될 수 있다. 해결방법1. synchronized 사용12345678910111213public class Singleton { private static Singleton uniqueInstance; private Singleton(){} public static synchronized Singleton getInstance(){ if (uniqueInstance == null){ uniqueInstance = new Singleton(); } return uniqueInstance; } } 단점 : 속도 저하 → 메소드가 synchronized 되면 약 100배 정도 성능 저하가 일어난다고 한다. 2. 인스턴스를 처음부터 만들어 버림12345678910public class Singleton { private static Singleton uniqueInstance = new Singleton(); private Singleton(){} public static synchronized Singleton getInstance(){ return uniqueInstance; } } 클래스가 로딩될 때 JVM에서 Singleton의 유일한 인스턴스를 생성해준다. 3. DCL(Double-Checking Locking) 사용1234567891011121314151617public class Singleton { private volatile static Singleton uniqueInstance; private Singleton(){} public static Singleton getInstance(){ if (uniqueInstance == null){ synchronized (Singleton.class){ if(uniqueInstance == null){ uniqueInstance = new Singleton(); } } } return uniqueInstance; } } volatile 키워드를 사용하면 자바의 일종의 최적화인 리오더링(보통 컴파일 과정에서 일어나며, 프로그래머가 만들어낸 코드는 컴파일 될 때 좀더 빠르게 실행될 수 있도록 조작이 가해져 최적하됨)을 회피하여 읽기와 쓰기순서를 보장한다. 멀티스레딩을 쓰더라도 uniqueInstance변수가 Singleton 인스턴스로 초기화 되는 과정이 올바르게 진행되도록 할 수 있다. DCL은 자바1.5이상의 버전에서만 사용가능하다. 자바 1.4 및 그 전에 나온 버전의 JVM 중에는 volatile 키워드를 사용하더라도 동기화가 잘 안되는 것이 많다. 일종의 버그. 요약 우리가 알고있던 싱글톤 패턴은 사실 싱글톤 패턴이 아님! 위의 3가지 방법을 사용하자 개인적으론 **생성자(2번)**가 가장 간단한 것 같음","link":"/2021/11/01/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/2021-10-19-%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4/2021-10-19-%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4/"},{"title":"키-값 저장소 설계","text":"비 관계형 데이터베이스고유식별자(key)를 키로 가짐 키와 값 사이의 연결 관계를 “키-값” 쌍(pair)라고 표현 분산 키-값 저장소의 CAP 정리데이터 일관성(Consistency), 가용성(Availability), 파티션 감내성(Partition Tolerance)라 표현하며,동시에 3가지 요구사항을 만족하는 것은 불가능하다는 정리 {: .image-center} 용어 정리데이터 일관성(Consistency) 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했느냐에 관계 없이 언제나 같은 데이터를 보게 되어야 한다. 가용성(Availability) 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다. 파티션 감내성(Partition Tolerance) 파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미한다. 파티션 감내는 네트워크에 파티션이 생기더라도 시스템은 계속 동작하여야 한다는 것을 뜻한다. 분산 키-값 저장소가 가져야하는 기능 목표/문제 기술 대규모 데이터 저장 안정 해시를 사용해 서버들에 부하 분산 읽기 연산에 대한 높은 가용성 보장 여러 데이터센터에 다중화 쓰기 연산에 대한 높은 가용성 보장 버저닝 및 벡터 시계를 사용한 충돌 해소 데이터 파티션 안정 해시 점진적 규모 확장성 안정 해시 다양성(heterogeneity) 안정 해시 조절 가능한 데이터 일관성 정족수 합의 일시적 장애 처리 느슨한 정족수 프로토콜과 단서 후 임시 위탁 영구적 장애 처리 머클 트리 데이터 센터 장애 대응 여러 데이터 센터에 걸친 데이터 다중화","link":"/2021/11/01/%EA%B0%80%EC%83%81%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84%EA%B8%B0%EC%B4%88/2021-10-13-%ED%82%A4-%EA%B0%92-%EC%A0%80%EC%9E%A5%EC%86%8C-%EC%84%A4%EA%B3%84/2021-10-13-%ED%82%A4-%EA%B0%92-%EC%A0%80%EC%9E%A5%EC%86%8C-%EC%84%A4%EA%B3%84/"},{"title":"팩토리 패턴","text":"⛳ 들어가기 전에..회사에서 같은 프로세스 내에서 각각의 제휴사에 서비스를 인터페이스해야 하는 경우가 있었다. 전체적인 프로세스 플로우를 인터페이스로, 제휴사를 클래스(Bean)로 만들어 팩토리 패턴으로 구현하였다. 동일한 프로세스 플로우 내에서 각기 다른 제휴사의 API와 연동해야 했는데 팩토리 패턴이 많은 도움이 되었다. 👋 팩토리패턴이란⚾ 팩토리 메소드 패턴 객체를 생성하기 위한 인터페이스를 정의하는데,어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정하게 만든다.즉, 팩토리 메소드 패턴을 이용하면 클래스의 인스턴스를 만드는 일을 서브클래스에게 맡기는 것. 🥎 추상 팩토리 패턴 인터페이스를 이용하여 서로 연관된,또는 의존하는 객체를 구상 클래스를 지정하지 않고도 생성한다. 🎩 팩토리패턴이 필요한 이유new를 사용하는 것은 구상 클래스의 인스턴스를 만드는 것이다.당연히! 인터페이스가 아닌 특정 구현을 사용하게 되어버리는 것.일련의 구상 클래스들이 있을때는 어쩔수 없이 다음과 같은 코드를 만들어야 하는 경우가 있다. 12345Duck duck;if ( type == picnic ) duck = new MallardDuck();else if ( type == hunting ) duck = new DecoyDuck();else if ( type == inBathTub) duck = new RubberDuck(); 이런 코드가 있다는 것은, 뭔가 변경하거나 확장해야 할 때 코드를 다시 확인하고 추가 또는 제거해야 한다는 것을 의미한다.인터페이스에 맞춰서 코딩을 하면 시스템에서 일어날 수 있는 여러 변화를 이겨낼 수 있다.다형성 덕분에 어떤 클래스든 특정 인터페이스만 구현하면 사용할수 있기 때문이다. 반대로. 구상 클래스를 많이 사용하면 새로운 구상 클래스가 추가될 때마다 코드를 고쳐야 하기때문에 많은 문제가 생길수 있다.즉, 변화에 대해 닫혀 있는 코드가 되어버리는 것이다. 바뀔 수 있는 부분을 찾아내서 바뀌지 않는 부분하고 분리시켜야 한다는 원칙. 🎢 고전적인 팩토리 패턴 피자 가게를 운영하고 있고 피자가게 클래스를 만들어야 된다고 가정한다. 피자가게는 다양한 피자가 있을 수 있다.또한 다양한 피자가게가 있을 수 있다. 🎞 기존소스12345678910111213141516Pizza orderPizza(String type) { Pizza pizza; //추가하거나 제거 시 매번 바뀌어야 하는부분 if(type.equals(&quot;cheese&quot;)) pizza = new CheesePizza(); else if(type.equals(&quot;greek&quot;)) pizza = new GreekPizza(); else if(type.equals(&quot;pepperoni&quot;)) pizza = new PepperoniPizza(); // pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza;} 1. 피자 팩토리를 만든다.1234567891011121314public class SimplePizzaFactory { public Pizza createPizza(String type){ //이런 경우에는 static메소드로 선언하는 경우가 종종 있음. Pizza pizza = null; if(pizza.equals(&quot;cheese&quot;)) pizza = new CheesePizza(); if(pizza.equals(&quot;pepper&quot;)) pizza = new PepperoniPizza(); if(pizza.equals(&quot;clam&quot;)) pizza = new ClamPizza(); if(pizza.equals(&quot;veggie&quot;)) pizza = new VeggiePizza(); return pizza;}} 2. 피자 가게를 만든다.12345678910111213141516171819202122public class PizzaStore{ SimplePizzaFactory simplePizzaFactory; public PizzaStore(SimplePizzaFactory simplePizzaFactory) { this.simplePizzaFactory = simplePizzaFactory; //피자 가게를 동적으로 설정 } public Pizza orderPizza(String type){ Pizza pizza; pizza = simplePizzaFactory.createPizza(type); //수정 안해도 됨 pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; }} 3. 다양한 피자가게가 생긴다.12345PizzaStore nyStore = new PizzaStore(new NYPizzaFactory());nyStore.orderPizza(&quot;cheese&quot;);PizzaStore chicagoStore = new PizzaStore(new ChicagoPizzafactory());chicagoStore.orderPizza(&quot;cheese&quot;); 각 피자가게에서 orderPizza() 만 호출하면 피자를 생성할 수 있게 되었다. 그러나, 각 팩토리를 가진 피자가게 체인점들이 서로의 구현방식이 달라지는 일이 발생할수도 있게 되었다.(PizzaStore가 각각 있다보니 굽는 방식이 달라진다거나 피자를 자르는 단계를 빼먹거나 하는..) 🎟 팩토리 메소드 패턴 피자가게와 피자 제작 과정 전체를 하나로 묶어주는 프레임워크를 만들어야 된다는 결론!!파자를 만드는 활동 자체는 전부 PizzaStore 클래스에 국한시키면서도 분점마다 고유의 스타일을 살릴 수 있는 방법은 ?? 4. 피자가게를 묶는 추상 클래스를 만든다. (프렌차이즈 본사랄까..)12345678910111213141516public abstract class PizzaStore{ //추상 클래스로 구현 public Pizza orderPizza(String type){ Pizza pizza; pizza = createPizza(type); pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); return pizza; } abstract Pizza createPizza(String type); //Pizza 인스턴스를 만드는 일은 팩토리 역할을 하는 메소드에서 맡아 처리} 5. 각 피자가게에서 추상클래스(본사)를 상속받게 한다.이제 각 분점을 위한 지역별로 서브클래스를 만들어줘야 한다. 피자의 스타일은 각 서브클래스에서 결정. 이제 ChicagoPizzaStore, NYPizzaStore 에는 구상 피자클래스를 분기해주는 각각의 createPizza() 메소드가 있다. 1234567891011121314151617181920212223242526272829public class NYPizzaStore extends PizzaStore{ @Override public Pizza createPizza(String type){ Pizza pizza = null; if(type.equals(&quot;cheese&quot;)) pizza = new NYStyleCheesePizza(); if(type.equals(&quot;peper&quot;)) pizza = new NYStylePepperoniPizza(); if(type.equals(&quot;clam&quot;)) pizza = new NYStyleClamPizza(); if(type.equals(&quot;veggie&quot;)) pizza = new NYStyleVeggiePizza(); return pizza; }}public class ChicagoPizzaStore extends PizzaStore{ @Override public Pizza createPizza(String type){ Pizza pizza = null; if(type.equals(&quot;cheese&quot;)) pizza = new ChicagoStyleCheesePizza(); if(type.equals(&quot;peper&quot;)) pizza = new ChicagoStylePepperoniPizza(); if(type.equals(&quot;clam&quot;)) pizza = new ChicagoStyleClamPizza(); if(type.equals(&quot;veggie&quot;)) pizza = new ChicagoStyleVeggiePizza(); return pizza; }} 6. 피자 추상클래스를 만든다.(순수한 피자 그 자체)12345678910111213141516171819202122public abstract class Pizza{ String name; String dough; String sauce; ArrayList&lt;String&gt; toppings = new ArrayList&lt;&gt;(); public void prepare(){ System.out.println(&quot;Preparing : &quot;+name); System.out.println(&quot;Tossing dough...&quot;); System.out.println(&quot;Adding source&quot;); System.out.println(&quot;Adding toppings&quot;); for (String topping : toppings) { System.out.println(&quot;\\ttopping : &quot;+topping); } } public void bake(){ System.out.println(&quot;Bake for 25 minutes at 350&quot;); } public void cut(){ System.out.println(&quot;Cutting the pizza into diagonal slices&quot;); } public void box(){ System.out.println(&quot;Place pizza in official PizzaStore box&quot;); } public String getname(){ return this.name; } } 7. 다양한 피자를 만들어 피자 추상클래스를 상속한다.12345678910111213141516171819202122public class NYStyleCheesePizza extends Pizza{ public NYStyleCheesePizza() { this.name = &quot;NY Style CheesePizza&quot;; this.dough = &quot;Thin Crust Dough&quot;; this.sauce = &quot;Marinara Sauce&quot;; this.toppings.add(&quot;Grated Reggiano Cheese&quot;); } } public class ChicagoStyleCheesePizza extends Pizza{ public ChicagoStyleCheesePizza() { this.name = &quot;Chicago Style CheesePizza&quot;; this.dough = &quot;Extra Thick Crust Dough&quot;; this.sauce = &quot;Plum Tomato Sauce&quot;; this.toppings.add(&quot;Shredded mozzarella Cheese&quot;); } @Override public void cut() { System.out.println(&quot;Cutting the pizza into square slices&quot;); } //바꾸고 싶은 메소드만 오버라이딩 } 8. 피자를 주문한다.1234567891011121314public class PizzaTestDrive {public static void main(String[] args) { PizzaStore nyStore = new NYPizzaStore(); PizzaStore chicagoStore = new ChicagoPizzaStore(); Pizza nySytpePizza = nyStore.orderPizza(&quot;cheese&quot;); System.out.println(nySytpePizza.getname()); Pizza chicagoStypePizza = chicagoStore.orderPizza(&quot;cheese&quot;); System.out.println(chicagoStypePizza.getname());}} 모든 팩토리 패턴에서는 객체 생성을 캡슐화 한다. 팩토리 메소드 패턴에서는 서브 클래스에서 어떤 클래스를 만들지를 결정하게 함으로써 객체 생성을 캡슐화 한다. 생산자 클래스(피자가게) 제품 클래스(피자) 위 클래스 다이어그램에서는 PizzaStore 추상 클래스에서 객체를 만들기 위한 메소드,즉 팩토리 메소드를 위한 인터페이스를 제공한다는 것을 알수있다. PizzaStore에 구현되어 있는 다른 메소드 orderPizza() 에서는 팩토리 메소드에 의해 생산된 제품을 가지고 필요한 작업을 처리한다.하지만 실제 팩토리 메소드를 구현하고 제품(객체 인스턴스)을 만들어 내는 일은 서브클래스에서만 할수 있다. 🎭 디자인원칙 : 의존성 뒤집기 원칙 추상화된 것에 의존하도록 만들어라. 구상 클래스에 의존하도록 만들지 않도록 한다. 구현클래스에 의존하는 형태 123PizzaStore -&gt; NYStyleCheesePizzaPizzaStore -&gt; ChicagoStypeCheesePizzaPizzaStore -&gt; NYStyleVeggiePizza -&gt; 좋지않음 추상클래스(인터페이스)를 의존하는 형태 1234PizzaStore -&gt; PizzaPizza &lt;- NYStyleCheesePizzaPizza &lt;- ChicagoStyleCheesePizzaPizza &lt;- NYStyleVeggiePizza -&gt; 좋음 🛒 원칙에 도움이 되는 가이드1. 어떤 변수에도 구상 클래스에 대한 레퍼런스를 지정하지 않는다. new 연산자를 사용하면 레퍼런스를 사용하게 되는 것이다. 2. 구상 클래스에서 유도된 클래스를 만들지 않는다. 구상클래스에서 유도된 클래스를 만들면 특정 구상 클래스에 의존하게된다, 추상화 된 것을 사용해야 한다. 3. 베이스 클래스에 이미 구현되어 있던 메소드를 오버라이드 하지 않는다. 이미 구현되어 있는 메소드를 오버라이드 한다는 것은 애초부터 베이스 클래스가 제대로 추상화 된것이 아니었다고 볼 수 있다. 베이스 클래스에서 메소드를 정의할 때는 모든 서브 클래스에서 공유할 수 있는 것만 정의해야한다. 🦺 추상 팩토리 패턴이렇게 PizzaStore 디자인이 모양새를 갖췄다. 유연한 프레임워크도 만들어 졌고, 디자인 원칙도 충실하게 지켰다. 각각 체인점들이 미리 정해놓은 절차를 잘 따르고 있지만 몇몇 체인점들이 자잘한 재료를 더 싼 재료로 바꿔서 원가를 절감해 마진을 남기고 있다. 원재료의 품질까지 관리하는 방법이 있을까?? 원재료 군을 만들어 파악하자. 제품에 들어가는 재료군(반죽, 소스, 치즈, 야채, 고기)은 같지만, 지역마다 재료의 구체적인 내용이 조금씩 다르다. 지역별로 팩토리를 만들어 각 생성 메소드를 구현하는 PizzaingredientFactory 클래스를 만든다. ReggianoCheese, RedPeppers, ThickCrustDough와 같이 팩토리에서 사용할 원재료 클래스들을 구현한다. 만든 원재료 공장을 PizzaStore 코드에서 사용하도록 함으로써 하나로 묶어준다. 9. 원재료 공장을 만든다.12345678public interface PizzaIngredientFactory {public Dough createDough();public Sauce createSauce();public Cheese createCheese();public Veggies[] createVeggies();public Pepperoni createPepperoni();public Clams createClams();} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class NYPizzaingredientFactory implements PizzaIngredientFactory{ @Override public Dough createDough() { return new ThinCrustdough(); } @Override public Sauce createSauce() { return new MarinaraSauce(); } @Override public Cheese createCheese() { return new ReggianoCheese(); } @Override public Veggies[] createVeggies() { Veggies veggies[] = { new Farlic(), new Onion(), new Mushroom(), new RedPepper() }; return veggies; } @Override public Pepperoni createPepperoni() { return new SlicedPepperoni(); } @Override public Clams createClams() { return new Freshclams(); } } public class ChicagoPizzaingredientFactory implements PizzaIngredientFactory{ @Override public Dough createDough() { return new ThickCrustDough(); } @Override public Sauce createSauce() { return new PlumTomatoSauce(); } @Override public Cheese createCheese() { return new MozzarellaCheese(); } @Override public Veggies[] createVeggies() { Veggies veggies[] = { new BlackOlives(), new Spinach(), new EggPlant()}; return veggies; } @Override public Pepperoni createPepperoni() { return new Slicedpepperoni(); } @Override public Clams createClams() { return new FrozenClam(); }} 10. 피자마다 재료는 다르다.123456789101112131415public abstract class Pizza{String name;Dough dough;Sauce sauce;Veggies veggies[];Cheese cheese;Pepperoni pepperoni;Clams clams;public abstract void prepare(); //추상 메소드로 변경됨.public void bake(){ System.out.println(&quot;Bake for 25 minutes at 350&quot;); }public void cut(){ System.out.println(&quot;Cutting the pizza into diagonal slices&quot;); }public void box(){ System.out.println(&quot;Place pizza in official PizzaStore box&quot;); }public String getname(){ return this.name; }} 123456789101112131415161718192021222324252627282930313233 public class CheesePizza extends Pizza{ PizzaIngredientFactory ingredientFactory; public CheesePizza(PizzaIngredientFactory ingredientFactory) { this.ingredientFactory = ingredientFactory; } @Override public void prepare() { this.dough = ingredientFactory.createDough(); this.sauce = ingredientFactory.createSauce(); this.cheese = ingredientFactory.createCheese(); } } public class ClamPizza extends Pizza{ PizzaIngredientFactory ingredientFactory; public ClamPizza(PizzaIngredientFactory ingredientFactory) { this.ingredientFactory = ingredientFactory; } @Override public void prepare() { this.dough = ingredientFactory.createDough(); this.sauce = ingredientFactory.createSauce(); this.cheese = ingredientFactory.createCheese(); this.clams = ingredientFactory.createClams(); }} 11. 피자마다, 지역마다 다른 피자를 만든다.12345678910111213141516171819202122232425262728public class NYPizzaStore extends PizzaStore{@Overridepublic Pizza createPizza(String type){ Pizza pizza = null; PizzaIngredientFactory ingredientFactory = new NYPizzaingredientFactory(); if(type.equals(&quot;cheese&quot;)){ pizza = new CheesePizza(ingredientFactory); pizza.setName(ingredientFactory.NY_STYLE+&quot; Cheese Pizza&quot;); }else if(type.equals(&quot;peper&quot;)){ pizza = new PepperoniPizza(ingredientFactory); pizza.setName(ingredientFactory.NY_STYLE+&quot; Pepperoni Pizza&quot;); }else if(type.equals(&quot;clam&quot;)){ pizza = new ClamPizza(ingredientFactory); pizza.setName(ingredientFactory.NY_STYLE+&quot; Clam Pizza&quot;); }else if(type.equals(&quot;veggie&quot;)){ pizza = new VeggiePizza(ingredientFactory); pizza.setName(ingredientFactory.NY_STYLE+&quot; Veggie Pizza&quot;); } return pizza;}} ⛳ 프로세스 정리 이제 전체적인 흐름은. 뉴욕 피자가게를 만든다. 1PizzaStore nyPizzaStore = new NYPizzaStore(); 주문을 한다. 1nyPizzaStore.orderPizza(&quot;cheese&quot;); orderPizza 메소드에서는 우선 createPizza() 메소드를 호출한다 1Pizza pizza = createPizza(&quot;cheese&quot;); createPizza() 메소드가 호출되면 원재료 공장이 돌아가기 시작한다. 1Pizza pizza = new CheesePizza(nyIngredientFactory); 피자를 준비하는 prepare()메소드가 호출되면 팩토리에 원재료 주문이 들어간다. 12345void prepare(){ dough = nyIngredientFactory.createDough(); sauce = nyIngredientFactory.createSauce(); cheese = nyIngredientFactory.createCheese(); } 준비단계가 끝나고 orderPizza() 메소드에서는 피자를 굽고, 자르고, 포장한다. 💎 요약추상 팩토리 패턴 제품군을 생성하기 위한 인터페이스를 생성하고, 그 인터페이스를 구성하여 사용할수 있게끔 하는것. 추상 메소드 패턴 하나의 추상클래스에서 추상 메소드를 만들고, 서브클래스들이 그 추상메소드를 구현하여 인스턴스를 만들게끔 하는것.","link":"/2021/11/01/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/2021-10-20-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%8C%A8%ED%84%B4/2021-10-20-%ED%8C%A9%ED%86%A0%EB%A6%AC-%ED%8C%A8%ED%84%B4/"}],"tags":[{"name":"m1","slug":"m1","link":"/tags/m1/"},{"name":"롤","slug":"롤","link":"/tags/%EB%A1%A4/"},{"name":"league of legend","slug":"league-of-legend","link":"/tags/league-of-legend/"},{"name":"mac on metal","slug":"mac-on-metal","link":"/tags/mac-on-metal/"},{"name":"시스템설계","slug":"시스템설계","link":"/tags/%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%84%A4%EA%B3%84/"},{"name":"대규모설계","slug":"대규모설계","link":"/tags/%EB%8C%80%EA%B7%9C%EB%AA%A8%EC%84%A4%EA%B3%84/"},{"name":"DB설계","slug":"DB설계","link":"/tags/DB%EC%84%A4%EA%B3%84/"},{"name":"서버설계","slug":"서버설계","link":"/tags/%EC%84%9C%EB%B2%84%EC%84%A4%EA%B3%84/"},{"name":"분산설계","slug":"분산설계","link":"/tags/%EB%B6%84%EC%82%B0%EC%84%A4%EA%B3%84/"},{"name":"면접","slug":"면접","link":"/tags/%EB%A9%B4%EC%A0%91/"},{"name":"안정해시","slug":"안정해시","link":"/tags/%EC%95%88%EC%A0%95%ED%95%B4%EC%8B%9C/"},{"name":"가상노드","slug":"가상노드","link":"/tags/%EA%B0%80%EC%83%81%EB%85%B8%EB%93%9C/"},{"name":"처리율제한","slug":"처리율제한","link":"/tags/%EC%B2%98%EB%A6%AC%EC%9C%A8%EC%A0%9C%ED%95%9C/"},{"name":"토큰버킷","slug":"토큰버킷","link":"/tags/%ED%86%A0%ED%81%B0%EB%B2%84%ED%82%B7/"},{"name":"누출버킷","slug":"누출버킷","link":"/tags/%EB%88%84%EC%B6%9C%EB%B2%84%ED%82%B7/"},{"name":"이동윈도로그","slug":"이동윈도로그","link":"/tags/%EC%9D%B4%EB%8F%99%EC%9C%88%EB%8F%84%EB%A1%9C%EA%B7%B8/"},{"name":"고정윈도카운터","slug":"고정윈도카운터","link":"/tags/%EA%B3%A0%EC%A0%95%EC%9C%88%EB%8F%84%EC%B9%B4%EC%9A%B4%ED%84%B0/"},{"name":"디자인패턴","slug":"디자인패턴","link":"/tags/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/"},{"name":"싱글톤","slug":"싱글톤","link":"/tags/%EC%8B%B1%EA%B8%80%ED%86%A4/"},{"name":"키값저장소","slug":"키값저장소","link":"/tags/%ED%82%A4%EA%B0%92%EC%A0%80%EC%9E%A5%EC%86%8C/"},{"name":"팩토리","slug":"팩토리","link":"/tags/%ED%8C%A9%ED%86%A0%EB%A6%AC/"}],"categories":[{"name":"게임","slug":"게임","link":"/categories/%EA%B2%8C%EC%9E%84/"},{"name":"가상면접 사례로 배우는 대규모 시스템 설계기초","slug":"가상면접-사례로-배우는-대규모-시스템-설계기초","link":"/categories/%EA%B0%80%EC%83%81%EB%A9%B4%EC%A0%91-%EC%82%AC%EB%A1%80%EB%A1%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84%EA%B8%B0%EC%B4%88/"},{"name":"디자인패턴","slug":"디자인패턴","link":"/categories/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/"}]}