---
title: "사용자 수에 따른 규모 확장성"
categories:
  - 가상면접 사례로 배우는 대규모 시스템 설계기초
tags:
  - 시스템설계
  - 대규모설계
  - DB설계
  - 서버설계 
  - 분산설계 
toc: true
toc_sticky: true
toc_label: "사용자 수에 따른 규모 확장성"
toc_icon: "sticky-note"
---

- 요약
    - 웹 계층은 무상태 계층으로
    - 모든 계층에 다중화 도입
    - 가능한 많은 데이터를 캐시할 것
    - 여러 데이터 센터를 지원할 것
    - 정적 콘텐츠는 CDN을 통해 서비스할 것
    - 데이터 계층은 샤딩을 통에 그 규모를 확장할 것
    - 각 계층은 독립적 서비스로 분할할 것
    - 시스템을 지속적으로 모니터링 하고, 자동화 도구들을 활용할 것
  
---

# 단일서버

## 시스템이 단일 서버로 구현되어있다고 가정할 시 프로세스

1. 사용자가 도메인(api.mysite.com)으로 접속한다.
2. DNS에 질의하여 IP주소로 반환된다. (DNS는 제3사업자임)
3. IP주소로 HTTP 요청
4. HTML or Json으로 응답

---

# 데이터베이스

## RDBMS vs NoSQL

- RDBMS
    - 오라클, MySQL, PostegreSQL
    - 열, 컬럼으로 표현
    - Join으로 합침
- NoSQL
    - MongoDB ...
    - Join 지원 안함

## NoSQL 쓰는 경우

- 속도 중요할 시
- 비정형 데이터일 시
- 데이터 직렬화, 역직렬화 용
- 대량의 데이터

---

# 수직적 규모 확장 vs 수평적 규모 확장

## Sacale-Up vs Sacale-Out

Scale-Up : 단일 서버 사양을 높임

Scale-Out : 서버 수를 추가

## Sacale-Up 아닌 Sacale-Out이 유리한 이유

- 한 대의 서버 메모리를 무한대로 증설할 방법이 없음
- 장애에 대한 자동복구 방안이나 다중화 제시 X

## 로드밸런서(LB)

- 트래픽 분산의 역할

## DB 다중화

- 이중화 시 master-slave로 나눔
- master는 write, slave는 read
- 보통 read연산 비중이 훨씬 높고 slave DB가 더 많음 → 성능

---

# 캐시

- 값비싼 연산 결과나 자주 참조되는 데이터를 저장하는 메모리

## 캐시 사용 시 고려해야 할 것

- 영속적인 데이터 X
- 만료(expire) 방식
    - LRU → 가장 자주 씀
    - LFU
    - FIFO
- 데이터 일관성 유지 방식

---

# 콘텐츠 전송 네크워크(CDN)

- 정적 콘텐츠 캐싱
- CSS, JS, 이미지, 비디오

---

# 무상태(stateless) 웹 계층

- Scale-Out 시 중요
- 상태정보를 웹 계층에서 제거

## 상태 정보를 웹 말고 DB에 저장

- MSA시 **공유저장소**를 활용
- Redis, NoSQL 활용

---

# 데이터센터

- 통상적으로 지리적으로 가장 가까운 곳으로 라우팅(Geo-routing)

## 구축 시 신경써야 할 것

- 트래픽 우회
- 데이터 동기화
- 테스트와 배포

→ Message Queue는 시스템이 독립적으로 확장할 수 있는 핵심전략

---

# 메시지 큐

- 무손실, 비동기
- pub-sub 방식


---

# 데이터베이스의 규모 확장

## 샤딩(sharding)

- DB를 scale-out 하는 것
- **모든 샤드는 같은 스키마를 쓰지만 데이터 중복은 없음**
- 샤딩 키를 정하는 것이 중요