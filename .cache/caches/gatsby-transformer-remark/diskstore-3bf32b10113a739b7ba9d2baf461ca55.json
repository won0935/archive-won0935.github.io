{"expireTime":9007200939154744000,"key":"transformer-remark-markdown-html-956c2ffc8003e6dca95b4be5fc216ea1-gatsby-remark-code-titlesgatsby-remark-embed-youtubegatsby-remark-imagesgatsby-remark-responsive-iframegatsby-remark-custom-blocksgatsby-remark-autolink-headersgatsby-remark-prismjsgatsby-remark-copy-linked-filesgatsby-remark-smartypants-","val":"<h1 id=\"spring-jdk-dynamic-proxy-vs-cglib---재원\" style=\"position:relative;\"><a href=\"#spring-jdk-dynamic-proxy-vs-cglib---%EC%9E%AC%EC%9B%90\" aria-label=\"spring jdk dynamic proxy vs cglib   재원 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[Spring] JDK Dynamic Proxy VS CGLIB - 재원</h1>\n<h1 id=\"ioc-컨테이너와-aop-proxy의-관계\" style=\"position:relative;\"><a href=\"#ioc-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%99%80-aop-proxy%EC%9D%98-%EA%B4%80%EA%B3%84\" aria-label=\"ioc 컨테이너와 aop proxy의 관계 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>IoC 컨테이너와 AOP Proxy의 관계</h1>\n<p><strong>Spring AOP</strong>는 Proxy의 메커니즘을 기반으로 AOP Proxy를 제공하고 있다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/55419159/199493071-61bc4982-a9ea-47ee-87ca-98c2cb481aa5.png\" alt=\"image\"></p>\n<p>다음 그림처럼 <strong>Spring AOP</strong>는 사용자의 특정 호출 시점에 IoC 컨테이너에 의해 AOP를 할 수 있는 <code class=\"language-text\">Proxy Bean</code>을 생성한다.</p>\n<p>동적으로 생성된 <code class=\"language-text\">Proxy Bean</code>은 타깃의 메소드가 호출되는 시점에 부가기능을 추가할 메소드를 자체적으로 판단하고 가로채어 부가기능을 주입해주는데, 이처럼 호출 시점에 동적으로 위빙을 한다 하여 <strong>런타임 위빙(Runtime Weaving)</strong>이라 한다.</p>\n<p>따라서 Spring AOP는 <strong>런타임 위빙의 방식을 기반</strong>으로 하고 있으며, Spring에선 런타임 위빙을 할 수 있도록 상황에 따라 <strong>JDK Dynamic Proxy</strong>와 <strong>CGLIB</strong> 방식을 통해 <code class=\"language-text\">Proxy Bean</code>을 생성을 해준다. 그렇다면 이 두 가지 AOP Proxy는 어떠한 상황에 생성하게 되는걸까?</p>\n<h1 id=\"두-가지-aop-proxy는-어떠한-상황에-생성하게-될까\" style=\"position:relative;\"><a href=\"#%EB%91%90-%EA%B0%80%EC%A7%80-aop-proxy%EB%8A%94-%EC%96%B4%EB%96%A0%ED%95%9C-%EC%83%81%ED%99%A9%EC%97%90-%EC%83%9D%EC%84%B1%ED%95%98%EA%B2%8C-%EB%90%A0%EA%B9%8C\" aria-label=\"두 가지 aop proxy는 어떠한 상황에 생성하게 될까 permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>두 가지 AOP Proxy는 어떠한 상황에 생성하게 될까?</h1>\n<p>Spring은 AOP Proxy를 생성하는 과정에서 자체 검증 로직을 통해 타깃의 인터페이스 유무를 판단한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/55419159/199493124-9884541d-902c-4988-8316-954db007dd13.png\" alt=\"image\"></p>\n<ul>\n<li>하나 이상의 인터페이스를 구현하고 있는 클래스라면 <strong>JDK Dynamic Proxy</strong> 방식으로 생성</li>\n<li>인터페이스를 구현하지 않은 클래스라면 <strong>CGLIB</strong> 방식으로 AOP 프록시를 생성</li>\n</ul>\n<h1 id=\"jdk-dynamic-proxy\" style=\"position:relative;\"><a href=\"#jdk-dynamic-proxy\" aria-label=\"jdk dynamic proxy permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JDK Dynamic Proxy</h1>\n<p><strong>JDK Dynamic Proxy</strong>란 Java의 리플렉션 패키지에 존재하는 <code class=\"language-text\">Proxy</code>라는 클래스를 통해 생성된 Proxy 객체를 의미한다. 핵심은 타깃의 <strong>인터페이스를 기준</strong>으로 <code class=\"language-text\">Proxy</code>를 생성해준다는 점이다.</p>\n<h2 id=\"jdk-dynamic-proxy의-proxy\" style=\"position:relative;\"><a href=\"#jdk-dynamic-proxy%EC%9D%98-proxy\" aria-label=\"jdk dynamic proxy의 proxy permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JDK Dynamic Proxy의 Proxy</h2>\n<p>JDK Dynamic Proxy를 사용하여 Proxy 객체를 생성하는 방법은 아래와 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token class-name\">Object</span> proxy <span class=\"token operator\">=</span> <span class=\"token class-name\">Proxy</span><span class=\"token punctuation\">.</span><span class=\"token function\">newProxyInstance</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ClassLoader</span>       <span class=\"token comment\">// 클래스로더</span>\n                                    <span class=\"token punctuation\">,</span> <span class=\"token class-name\">Class</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token operator\">?</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span>        <span class=\"token comment\">// 타깃의 인터페이스</span>\n                                    <span class=\"token punctuation\">,</span> <span class=\"token class-name\">InvocationHandler</span> <span class=\"token comment\">// 타깃의 정보가 포함된 Handler</span>\n              \t\t\t\t\t\t\t\t\t\t  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>단순히 리플랙션의 <code class=\"language-text\">Proxy</code> 클래스의 <code class=\"language-text\">newProxyInstance</code> 메소드를 사용하면 되는데, <strong>JDK Dynamic Proxy</strong>가 이 파라미터를 가지고 Proxy 객체를 생성해주는 과정은 다음과 같다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/55419159/199493214-8eafce4d-22ac-444c-af98-f55d690e518f.png\" alt=\"image\"></p>\n<p>타깃의 인터페이스를 구현하여 Proxy 생성</p>\n<ol>\n<li>타깃의 인터페이스를 자체적인 검증 로직을 통해 <code class=\"language-text\">ProxyFactory</code>에 의해 타깃의 인터페이스를 상속한 <code class=\"language-text\">Proxy</code> 객체 생성</li>\n<li><code class=\"language-text\">Proxy</code> 객체에 <code class=\"language-text\">InvocationHandler</code>를 포함시켜 하나의 객체로 반환</li>\n</ol>\n<h1 id=\"cglibcode-generator-library\" style=\"position:relative;\"><a href=\"#cglibcode-generator-library\" aria-label=\"cglibcode generator library permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CGLib(Code Generator Library)</h1>\n<p><strong>CGLib</strong>은 <strong>Code Generator Library</strong>의 약자로, 클래스의 <strong>바이트코드를 조작하여 Proxy 객체를 생성</strong>해주는 라이브러리다.</p>\n<p>Spring은 CGLib을 사용하여 인터페이스가 아닌 타깃의 클래스에 대해서도 Proxy를 생성해주고 있는데, CGLib은 <code class=\"language-text\">Enhancer</code>라는 클래스를 통해 Proxy를 생성할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre style=\"counter-reset: linenumber NaN\" class=\"language-java line-numbers\"><code class=\"language-java\"><span class=\"token class-name\">Enhancer</span> enhancer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Enhancer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         enhancer<span class=\"token punctuation\">.</span><span class=\"token function\">setSuperclass</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MemberService</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 타깃 클래스</span>\n         enhancer<span class=\"token punctuation\">.</span><span class=\"token function\">setCallback</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MethodInterceptor</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// Handler</span>\n<span class=\"token class-name\">Object</span> proxy <span class=\"token operator\">=</span> enhancer<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Proxy 생성</span></code><span aria-hidden=\"true\" class=\"line-numbers-rows\" style=\"white-space: normal; width: auto; left: 0;\"><span></span><span></span><span></span><span></span></span></pre></div>\n<p>다음과 같이 <strong>CGlib</strong>은 타깃의 <strong>클래스를 상속</strong>받아 다음 그림과 같이 Proxy를 생성해준다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/55419159/199493261-63ee0a19-8947-4efe-878c-e525fcc3d5a4.png\" alt=\"image\"></p>\n<p>타깃 클래스를 상속받아 Proxy 생성</p>\n<p>이 과정에서 CGLib은 타깃 클래스에 포함된 <strong>모든 메소드를 재정의</strong>하여 Proxy를 생성한다.</p>\n<p>이 때문에 CGLib은 Final 메소드 또는 클래스에 대해 재정의를 할 수 없으므로 Proxy를 생성할 수 없다는 단점이 있다.</p>\n<h2 id=\"권장하지-않았던-cglib\" style=\"position:relative;\"><a href=\"#%EA%B6%8C%EC%9E%A5%ED%95%98%EC%A7%80-%EC%95%8A%EC%95%98%EB%8D%98-cglib\" aria-label=\"권장하지 않았던 cglib permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>권장하지 않았던 CGLib</h2>\n<p>이러한 이유엔, 기존의 CGLiB은 <strong>3 가지의 한계</strong>가 존재했기 때문이다.</p>\n<ul>\n<li><code class=\"language-text\">net.sf.cglib.proxy.Enhancer</code> 의존성 추가</li>\n<li><code class=\"language-text\">default</code> 생성자</li>\n<li>타깃의 생성자 <strong>두 번</strong> 호출</li>\n</ul>\n<p>우선, 첫 번째는 Spring에서 기본적으로 지원하지 않는 방식이었기 때문에 별도로 <strong>의존성을</strong> <strong>추가하여</strong> 개발했다.</p>\n<p>그다음으론 CGLib을 구현하기 위해선 반드시 파라미터가 없는 <strong>default</strong> <strong>생성자가</strong> 필요했고,</p>\n<p>생성된 CGLib Proxy의 메소드를 호출하게 되면 <strong>타깃의</strong> <strong>생성자가</strong> <strong>2번</strong> 호출된다는 단점이 존재했다.</p>\n<h2 id=\"spring-boot가-선택한-cglib\" style=\"position:relative;\"><a href=\"#spring-boot%EA%B0%80-%EC%84%A0%ED%83%9D%ED%95%9C-cglib\" aria-label=\"spring boot가 선택한 cglib permalink\" class=\"anchor-header before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Spring Boot가 선택한 CGLib</h2>\n<p><strong>Spring Boot에서는 CGLib</strong>을 기본 전략으로 가져가고 있다.</p>\n<p>이유는 아래의 <strong>한계들이 해결되어서</strong> 이다.</p>\n<ul>\n<li>\n<p><code class=\"language-text\">~~net.sf.cglib.proxy.Enhancer</code> 의존성 추가~~</p>\n<ul>\n<li><a href=\"https://docs-stage.spring.io/spring/docs/current/spring-framework-reference/core.html#aop-api\">Spring 3.2</a> 버전부터 CGLib을 <code class=\"language-text\">Spring Core</code> 패키지에 포함시켜 더이상 의존성을 추가하지 않아도 개발할 수 있게 되었다.</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">~~default</code> 생성자~~</p>\n<ul>\n<li>4 버전에선 <a href=\"http://objenesis.org/\">Objensis 라이브러리</a> 의 도움을 받아 <code class=\"language-text\">default</code> 생성자 없이도 Proxy를 생성할 수 있게 되었다.</li>\n</ul>\n</li>\n<li>\n<p><del>타깃의 생성자 <strong>두 번</strong> 호출</del></p>\n<ul>\n<li>생성자가 2번 호출되던 상황도 개선되었다.</li>\n</ul>\n</li>\n</ul>"}